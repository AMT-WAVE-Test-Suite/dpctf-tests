<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>XSD Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script src="../lib/xsdValidation/output.js"></script>
    <script src="../lib/xsdValidation/validator.js"></script>
    <script>
      // Global variables
      var TEST_INFO = {
        id: "xsd-validation",
        title: "XSD Validation for MPD files",
        description:
          "Template for XSD Validations.",
        code: "xsd-validation.html",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = ["https://dash.akamaized.net/WAVE/vectors/cfhd_sets/15_30_60/t1/2023-09-01/stream.mpd"];
      var audioContentModel = []; // Now used for XSD file URL (for test purpose not)

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: audioContentModel,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      var logger = dpctfTest.getLogger();

      function executeTest(player, done, parameters) {
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        dpctfTest.asyncTest(async function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let mpd = getMPD();
          let schemes = loadMainSchemaAndDependencies();
          await Promise.all(schemes).then(data => 
            validate(mpd, data, logger)
          ).then(result => {
            logger.log("MPD Validation result: " + result);

            assert_true(result);
            test.done();
          });
        }, "MPD Schema Validation");

        player.playOnBufferLoaded(minBufferDuration).then(done);
      }

      // Save MPD file as utf-8 string
      function getMPD() {
        let mpd;
        logger.log("Loading MPD XML file...");
        logger.log("MPD URL:", videoContentModel[0]);

        mpd = fetch(videoContentModel[0])
        .then(res => res.text())
        .then(data => JSON.parse( JSON.stringify( mpd ) ))
        .then(data => {
          logger.log("Original MPD length:", mpd.length);
          logger.log("Checking for required schema attributes...");

          const hasXmlSchemaInstance = mpd.includes('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"');
          const hasSchemaLocation = mpd.includes('xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');

          logger.log("Has xmlns:xsi attribute:", hasXmlSchemaInstance);
          logger.log("Has schemaLocation attribute:", hasSchemaLocation);

          if (!hasXmlSchemaInstance || !hasSchemaLocation) {
            logger.log("Adding missing schema attributes to MPD...");
            mpd = mpd.replace('<MPD', '<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');
            logger.log("Schema attributes added");
          } else {
            logger.log("Schema attributes already present");
          }
          logger.log(" MPD XML loaded successfully, final length:", mpd.length);
        })

        return mpd;
      }

      // Load main schema and dependencies
      function loadMainSchemaAndDependencies() {
        let schemes = [];
        let xsdFileUrl = "https://raw.githubusercontent.com/Dash-Industry-Forum/MPEG-Conformance-and-reference-source/refs/heads/master/conformance/MPDValidator/schemas/DASH-MPD.xsd";
        logger.log("=== Loading main schema and dependencies ===");
        logger.log("Main XSD URL:", xsdFileUrl);
        
        try {
          // Load main schema
          logger.log("Fetching main schema from:", xsdFileUrl);
          schemes[0] = fetch(xsdFileUrl)
            .then(res => {
              logger.log("Main schema fetch response status:", res.status);
              return res.text();
            });
          mainSchemaContent = JSON.parse(JSON.stringify(mainSchemaContent));
          logger.log("Main schema loaded, content length:", mainSchemaContent.length);

          // Load all static dependencies
          logger.log("Starting dependency loading...");

          schemes[1] = fetch("../lib/xsdValidation/xlink.xsd").then(res => res.text())
          schemes[2] = fetch("../lib/xsdValidation/xml.xsd").then(res => res.text())

          logger.log("=== All schemas loaded successfully ===");
          logger.log("Total dependencies loaded:", dependencySchemas.size);
          logger.log("Dependency files:", Array.from(dependencySchemas.keys()));
        } catch (error) {
          console.error("=== Error loading schemas ===", error);
        }
        return schemes;
      }

      /* function validate() {
        logger.log("=== VALIDATION STARTED ===");

        try {
          const mainSchemaFileName = xsdFileUrl.split('/').pop();

          // 1. write XSD-files into a virtual directory
          logger.log("Writing xsd-schemas to virtual FS:");
          Module.FS.writeFile('/' + mainSchemaFileName, mainSchemaContent);
          dependencySchemas.forEach((content, fileName) => {
            logger.log(`  Writing: /${fileName}`);
            Module.FS.writeFile('/' + fileName, content);
          });

          // 2. write the XML-string to memory
          logger.log("Allocating memory for XML content...");
          const ptrXml = Module._malloc(lengthBytesUTF8(xml) + 1);
          stringToUTF8(xml, Module.HEAPU8, ptrXml, lengthBytesUTF8(xml) + 1);
          logger.log("XML written to memory at pointer:", ptrXml);

          // 3. parse XML-document
          logger.log("Parsing XML document...");
          const xmlDoc = Module.ccall(
            'xmlReadMemory',
            'number',
            ['number', 'number', 'number', 'number', 'number'],
            [ptrXml, lengthBytesUTF8(xml), null, null, 0]
          );

          // 4. load scheme from file DASH-MPD.xsd (that imports work)
          logger.log(`Creating schema parser context for: /${mainSchemaFileName}`);
          const schemaParserCtx = Module.ccall(
            'xmlSchemaNewParserCtxt',
            'number',
            ['string'],
            ['/' + mainSchemaFileName]
          );
          logger.log("Schema parser context created:", schemaParserCtx);

          // 5. parse schema and create validation context
          const schema = Module.ccall('xmlSchemaParse', 'number', ['number'], [schemaParserCtx]);
          logger.log("Schema parsed, pointer:", schema);
          const validCtx = Module.ccall('xmlSchemaNewValidCtxt', 'number', ['number'], [schema]);
          logger.log("Validation context created:", validCtx);

          // 6. validate XML
          logger.log("Validating XML document against schema...");
          const result = Module.ccall(
            'xmlSchemaValidateDoc',
            'number',
            ['number', 'number'],
            [validCtx, xmlDoc]
          );

          // 7. release memory
          logger.log("Cleaning up memory...");
          Module.ccall('xmlFreeDoc', 'void', ['number'], [xmlDoc]);
          Module.ccall('xmlSchemaFreeValidCtxt', 'void', ['number'], [validCtx]);
          Module.ccall('xmlSchemaFree', 'void', ['number'], [schema]);
          Module.ccall('xmlSchemaFreeParserCtxt', 'void', ['number'], [schemaParserCtx]);
          Module._free(ptrXml);

          logger.log("=== VALIDATION RESULT ===");
          logger.log("Raw validation result:", result);
          logger.log("Validation success:", result === 0);

          // 8. return result
          const isValid = result === 0;
          logger.log("=== VALIDATION FINISHED ===");
          return isValid;

        } catch (error) {
          console.error("=== VALIDATION ERROR ===", error);
          console.error("Error stack:", error.stack);
          return false;
        }
      }

      function stringToUTF8(str, heap, offset, maxBytesToWrite) {
        logger.log("In function stringToUTF8");
        if (!(maxBytesToWrite > 0)) return 0;
        const utf8encoder = new TextEncoder();
        const encoded = utf8encoder.encode(str);
        const len = Math.min(encoded.length, maxBytesToWrite - 1);
        heap.set(encoded.subarray(0, len), offset);
        heap[offset + len] = 0;
        return len;
      } */
    </script>
  </body>
</html>