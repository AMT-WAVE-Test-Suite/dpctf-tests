<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>XSD Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script src="../lib/xsdValidation/output.js"></script>
    <script>
      // Global variables
      var TEST_INFO = {
        id: "xsd-validation",
        title: "XSD Validation for MPD files",
        description:
          "Template for XSD Validations.",
        code: "xsd-validation.html",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = ["https://dash.akamaized.net/WAVE/vectors/cfhd_sets/15_30_60/t33/2023-09-01/stream.mpd"];
      var xsdFileUrl = ["https://raw.githubusercontent.com/Dash-Industry-Forum/MPEG-Conformance-and-reference-source/refs/heads/master/conformance/MPDValidator/schemas/DASH-MPD.xsd"]; // Now used for XSD file URL

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: xsdFileUrl,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      var logger = dpctfTest.getLogger();
      var xml;
      var mainSchemaContent;
      var dependencySchemas = new Map(); // Store all dependency schemas

      // Initialize the loading process
      initializeSchemas();

      async function initializeSchemas() {
        logger.log("INITIALIZATION STARTED");
        try {
          await getXml();
          await loadMainSchemaAndDependencies();
          logger.log("INITIALIZATION COMPLETED SUCCESSFULLY ");
        } catch (error) {
          logger.error("INITIALIZATION FAILED ", error);
        }
      }

      function executeTest(player, done, parameters) {
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        dpctfTest.asyncTest(function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let result = validate();

          logger.log("MPD Validation result: " + result);

          assert_true(result);
          test.done();

        }, "MPD Schema Validation");

        player.playOnBufferLoaded(minBufferDuration).then(done);
      }

      // Save MPD file as utf-8 string
      async function getXml() {
        logger.log("Loading MPD XML file...");
        logger.log("MPD URL:", videoContentModel[0]);

        xml = await fetch(videoContentModel[0])
        .then(res => {
          logger.log("MPD fetch response status:", res.status);
          return res.text();
        });
        xml = JSON.parse( JSON.stringify( xml ) );

        logger.log("Original XML length:", xml.length);
        logger.log("Checking for required schema attributes...");

        const hasXmlSchemaInstance = xml.includes('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"');
        const hasSchemaLocation = xml.includes('xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');

        logger.log("Has xmlns:xsi attribute:", hasXmlSchemaInstance);
        logger.log("Has schemaLocation attribute:", hasSchemaLocation);

        if (!hasXmlSchemaInstance || !hasSchemaLocation) {
          logger.log("Adding missing schema attributes to MPD...");
          xml = xml.replace('<MPD', '<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');
          logger.log("Schema attributes added");
        } else {
          logger.log("Schema attributes already present");
        }

        logger.log(" MPD XML loaded successfully, final length:", xml.length);
      }

      // Load main schema and automatically discover and load dependencies
      async function loadMainSchemaAndDependencies() {
        logger.log("=== Loading main schema and dependencies ===");
        logger.log("Main XSD URL:", xsdFileUrl);

        try {
          // Load main schema
          logger.log("Fetching main schema from:", xsdFileUrl);
          mainSchemaContent = await fetch(xsdFileUrl)
            .then(res => {
              logger.log("Main schema fetch response status:", res.status);
              return res.text();
            });
          mainSchemaContent = JSON.parse(JSON.stringify(mainSchemaContent));
          logger.log("Main schema loaded, content length:", mainSchemaContent.length);

          // Find and load all dependencies recursively
          logger.log("Starting recursive dependency loading...");
          await loadDependenciesRecursively(mainSchemaContent, new Set());

          logger.log("=== All schemas loaded successfully ===");
          logger.log("Total dependencies loaded:", dependencySchemas.size);
          logger.log("Dependency files:", Array.from(dependencySchemas.keys()));
        } catch (error) {
          logger.error("=== Error loading schemas ===", error);
          throw error;
        }
      }

      // Extract dependencies from XSD content and load them recursively
      async function loadDependenciesRecursively(schemaContent, loadedSchemas) {
        const dependencies = extractDependencies(schemaContent);
        logger.log("Dependencies found:", dependencies.length);

        for (const dependency of dependencies) {
          const downloadUrl = dependency.domain + dependency.fileName;
          logger.log(`Processing dependency: "${downloadUrl}"`);

          if (loadedSchemas.has(downloadUrl)) {
            logger.log(`Skipping already loaded schema: ${downloadUrl}`);
            continue; // Already loaded
          }

          loadedSchemas.add(downloadUrl);
          logger.log(`Added to loaded schemas: ${downloadUrl}`);

          try {
            logger.log(`Fetching dependency: ${downloadUrl}`);

            const xsdDependency = await fetch(downloadUrl)
              .then(res => {
                logger.log(`Dependency fetch response status for ${downloadUrl}:`, res.status);
                if (!res.ok) {
                  throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.text();
              });
            const xsdDependencyString = JSON.parse(JSON.stringify(xsdDependency));

            logger.log(`Successfully loaded dependency "${fileName}", content length:`, xsdDependencyString.length);
            dependencySchemas.set(fileName, xsdDependencyString);

            // Recursively load dependencies of this dependency
            logger.log(`Recursively checking dependencies for ${fileName}`);
            await loadDependenciesRecursively(xsdDependencyString, loadedSchemas);

          } catch (error) {
            logger.warn(`Failed to load dependency "${fileName}" from ${resolvedUrl}:`, error.message);
          }
        }

        logger.log("--- loadDependenciesRecursively completed ---");
      }

      // Extract import and include statements from XSD content
      function extractDependencies(schemaContent) {
        logger.log("*** extractDependencies called ***");
        logger.log("Schema content length:", schemaContent.length);

        const dependencies = [];

        // Combined regex to capture both namespace and schemaLocation
        const importRegex = /<xs:import[^>]*namespace\s*=\s*["']([^"']*\/)[^"']*["'][^>]*schemaLocation\s*=\s*["']([^"']*)["'][^>]*>/gi;

        let match;

        logger.log("Searching for import statements...");
        // Find imports with potential namespace resolution
        while ((match = importRegex.exec(schemaContent)) !== null) {
          logger.log(`Regex match: "${match}"`);
          const namespace = match[1];
          const schemaLocation = match[2];

          logger.log(`Found import - namespace: "${namespace}", schemaLocation: "${schemaLocation}"`);

          const includeDependency = {
            domain: namespace,
            fileName: schemaLocation
          };
          logger.log(`Include dependency:`, includeDependency);
          dependencies.push(includeDependency);

        }
        return dependencies;
      }

      function validate() {
        logger.log("=== VALIDATION STARTED ===");

        try {
          const mainSchemaFileName = xsdFileUrl.split('/').pop()
          // 1. write XSD-files into a virtual directory
          logger.log("Writing xsd-schemas to virtual FS:");
          Module.FS.writeFile('/' + mainSchemaFileName, mainSchemaContent);
          dependencySchemas.forEach((xsdFile, fileName) => {
            logger.log(`  Writing: /${fileName}`);
            Module.FS.writeFile('/' + fileName, content);
          });

          // 2. write the XML-string to memory
          logger.log("Allocating memory for XML content...");
          const ptrXml = Module._malloc(lengthBytesUTF8(xml) + 1);
          stringToUTF8(xml, Module.HEAPU8, ptrXml, lengthBytesUTF8(xml) + 1);
          logger.log("XML written to memory at pointer:", ptrXml);

          // 3. parse XML-document
          logger.log("Parsing XML document...");
          const xmlDoc = Module.ccall(
            'xmlReadMemory',
            'number',
            ['number', 'number', 'number', 'number', 'number'],
            [ptrXml, lengthBytesUTF8(xml), null, null, 0]
          );

          // 4. load scheme from file DASH-MPD.xsd (that imports work)
          logger.log(`Creating schema parser context for: /${mainSchemaFileName}`);
          const schemaParserCtx = Module.ccall(
            'xmlSchemaNewParserCtxt',
            'number',
            ['string'],
            ['/' + mainSchemaFileName]
          );
          logger.log("Schema parser context created:", schemaParserCtx);

          // 5. parse schema and create validation context
          const schema = Module.ccall('xmlSchemaParse', 'number', ['number'], [schemaParserCtx]);
          logger.log("Schema parsed, pointer:", schema);
          const validCtx = Module.ccall('xmlSchemaNewValidCtxt', 'number', ['number'], [schema]);
          logger.log("Validation context created:", validCtx);

          // 6. validate XML
          logger.log("Validating XML document against schema...");
          const result = Module.ccall(
            'xmlSchemaValidateDoc',
            'number',
            ['number', 'number'],
            [validCtx, xmlDoc]
          );

          // 7. release memory
          logger.log("Cleaning up memory...");
          Module.ccall('xmlFreeDoc', 'void', ['number'], [xmlDoc]);
          Module.ccall('xmlSchemaFreeValidCtxt', 'void', ['number'], [validCtx]);
          Module.ccall('xmlSchemaFree', 'void', ['number'], [schema]);
          Module.ccall('xmlSchemaFreeParserCtxt', 'void', ['number'], [schemaParserCtx]);
          Module._free(ptrXml);

          logger.log("=== VALIDATION RESULT ===");
          logger.log("Raw validation result:", result);
          logger.log("Validation success:", result === 0);

          // 8. return result
          const isValid = result === 0;
          logger.log("=== VALIDATION FINISHED ===");
          return isValid;

        } catch (error) {
          logger.error("=== VALIDATION ERROR ===", error);
          logger.error("Error stack:", error.stack);
          return false;
        }
      }

      function stringToUTF8(str, heap, offset, maxBytesToWrite) {
        logger.log("In function stringToUTF8");
        if (!(maxBytesToWrite > 0)) return 0;
        const utf8encoder = new TextEncoder();
        const encoded = utf8encoder.encode(str);
        const len = Math.min(encoded.length, maxBytesToWrite - 1);
        heap.set(encoded.subarray(0, len), offset);
        heap[offset + len] = 0;
        return len;
      }
    </script>
  </body>
</html>