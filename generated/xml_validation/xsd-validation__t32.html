<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>XSD Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script src="../lib/xsdValidation/output.js"></script>
    <script>
      // Global variables
      var TEST_INFO = {
        id: "xsd-validation",
        title: "XSD Validation for MPD files",
        description:
          "Template for XSD Validations.",
        code: "xsd-validation.html",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = ["https://dash.akamaized.net/WAVE/vectors/cfhd_sets/15_30_60/t32/2023-09-01/stream.mpd"];
      var xsdFileUrl = []; // Now used for XSD file URL

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: xsdFileUrl,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      var logger = dpctfTest.getLogger();
      var xml;
      var mainSchemaContent;
      var dependencySchemas = new Map(); // Store all dependency schemas

      // Initialize the loading process
      initializeSchemas();

      async function initializeSchemas() {
        logger.log("INITIALIZATION STARTED");
        try {
          await getXml();
          await loadMainSchemaAndDependencies();
          logger.log("INITIALIZATION COMPLETED SUCCESSFULLY ");
        } catch (error) {
          logger.error("INITIALIZATION FAILED ", error);
        }
      }

      function executeTest(player, done, parameters) {
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        dpctfTest.asyncTest(function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let result = validate();

          logger.log("MPD Validation result: " + result);

          assert_true(result);
          test.done();

        }, "MPD Schema Validation");

        player.playOnBufferLoaded(minBufferDuration).then(done);
      }

      // Save MPD file as utf-8 string
      async function getXml() {
        logger.log("Loading MPD XML file...");
        logger.log("MPD URL:", videoContentModel[0]);

        xml = await fetch(videoContentModel[0])
        .then(res => {
          logger.log("MPD fetch response status:", res.status);
          return res.text();
        });
        xml = JSON.parse( JSON.stringify( xml ) );

        logger.log("Original XML length:", xml.length);
        logger.log("Checking for required schema attributes...");

        const hasXmlSchemaInstance = xml.includes('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"');
        const hasSchemaLocation = xml.includes('xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');

        logger.log("Has xmlns:xsi attribute:", hasXmlSchemaInstance);
        logger.log("Has schemaLocation attribute:", hasSchemaLocation);

        if (!hasXmlSchemaInstance || !hasSchemaLocation) {
          logger.log("Adding missing schema attributes to MPD...");
          xml = xml.replace('<MPD', '<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');
          logger.log("Schema attributes added");
        } else {
          logger.log("Schema attributes already present");
        }

        logger.log(" MPD XML loaded successfully, final length:", xml.length);
      }

      // Load main schema and automatically discover and load dependencies
      async function loadMainSchemaAndDependencies() {
        logger.log("=== Loading main schema and dependencies ===");
        logger.log("Main XSD URL:", xsdFileUrl);

        try {
          // Load main schema
          logger.log("Fetching main schema from:", xsdFileUrl);
          mainSchemaContent = await fetch(xsdFileUrl)
            .then(res => {
              logger.log("Main schema fetch response status:", res.status);
              return res.text();
            });
          mainSchemaContent = JSON.parse(JSON.stringify(mainSchemaContent));
          logger.log("Main schema loaded, content length:", mainSchemaContent.length);

          // Extract base URL for relative imports
          const baseUrl = getBaseUrl(xsdFileUrl);
          logger.log("Base URL for relative imports:", baseUrl);

          // Find and load all dependencies recursively
          logger.log("Starting recursive dependency loading...");
          await loadDependenciesRecursively(mainSchemaContent, baseUrl, new Set());

          logger.log("=== All schemas loaded successfully ===");
          logger.log("Total dependencies loaded:", dependencySchemas.size);
          logger.log("Dependency files:", Array.from(dependencySchemas.keys()));
        } catch (error) {
          logger.error("=== Error loading schemas ===", error);
          throw error;
        }
      }

      // Extract dependencies from XSD content and load them recursively
      async function loadDependenciesRecursively(schemaContent, baseUrl, loadedSchemas) {
        logger.log("--- loadDependenciesRecursively called ---");
        logger.log("Base URL:", baseUrl);
        logger.log("Already loaded schemas:", Array.from(loadedSchemas));

        const dependencies = extractDependencies(schemaContent);
        logger.log("Dependencies found:", dependencies.length);

        for (const dependency of dependencies) {
          const resolvedUrl = dependency.resolvedUrl;
          const fileName = dependency.fileName;

          logger.log(`Processing dependency - fileName: "${fileName}", resolvedUrl: "${resolvedUrl}"`);

          if (loadedSchemas.has(resolvedUrl)) {
            logger.log(`Skipping already loaded schema: ${resolvedUrl}`);
            continue; // Already loaded
          }

          loadedSchemas.add(resolvedUrl);
          logger.log(`Added to loaded schemas: ${resolvedUrl}`);

          try {
            logger.log(`Fetching dependency: ${resolvedUrl}`);

            const dependencyContent = await fetch(resolvedUrl)
              .then(res => {
                logger.log(`Dependency fetch response status for ${resolvedUrl}:`, res.status);
                if (!res.ok) {
                  throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                return res.text();
              });
            const cleanContent = JSON.parse(JSON.stringify(dependencyContent));

            logger.log(`Successfully loaded dependency "${fileName}", content length:`, cleanContent.length);
            dependencySchemas.set(fileName, cleanContent);

            // Recursively load dependencies of this dependency
            const depBaseUrl = getBaseUrl(resolvedUrl);
            logger.log(`Recursively checking dependencies for ${fileName} with base URL: ${depBaseUrl}`);
            await loadDependenciesRecursively(cleanContent, depBaseUrl, loadedSchemas);

          } catch (error) {
            logger.warn(`Failed to load dependency "${fileName}" from ${resolvedUrl}:`, error.message);
          }
        }

        logger.log("--- loadDependenciesRecursively completed ---");
      }

      // Extract import and include statements from XSD content
      function extractDependencies(schemaContent) {
        logger.log("*** extractDependencies called ***");
        logger.log("Schema content length:", schemaContent.length);

        const dependencies = [];

        // Combined regex to capture both namespace and schemaLocation
        const importRegex = /<(?:xs:)?import[^>]*(?:namespace\s*=\s*["']([^"']+)["'][^>]*)?(?:schemaLocation\s*=\s*["']([^"']+)["'][^>]*)?[^>]*>/gi;
        const includeRegex = /<(?:xs:)?include[^>]*schemaLocation\s*=\s*["']([^"']+)["'][^>]*>/gi;

        let match;

        logger.log("Searching for import statements...");
        // Find imports with potential namespace resolution
        while ((match = importRegex.exec(schemaContent)) !== null) {
          const namespace = match[1];
          const schemaLocation = match[2];

          logger.log(`Found import - namespace: "${namespace}", schemaLocation: "${schemaLocation}"`);

          if (schemaLocation) {
            const resolvedDependency = resolveDependencyUrl(namespace, schemaLocation);
            logger.log(`Resolved dependency:`, resolvedDependency);
            dependencies.push(resolvedDependency);
          } else {
            logger.log("Import statement has no schemaLocation, skipping");
          }
        }

        logger.log("Searching for include statements...");
        // Find includes (no namespace resolution needed)
        while ((match = includeRegex.exec(schemaContent)) !== null) {
          const schemaLocation = match[1];
          logger.log(`Found include - schemaLocation: "${schemaLocation}"`);

          const includeDependency = {
            resolvedUrl: schemaLocation,
            fileName: schemaLocation
          };
          logger.log(`Include dependency:`, includeDependency);
          dependencies.push(includeDependency);
        }

        logger.log("*** extractDependencies result ***");
        logger.log("Total dependencies found:", dependencies.length);
        dependencies.forEach((dep, index) => {
          logger.log(`Dependency ${index + 1}: fileName="${dep.fileName}", resolvedUrl="${dep.resolvedUrl}"`);
        });

        return dependencies;
      }

      // Resolve dependency URL based on namespace and schemaLocation
      function resolveDependencyUrl(namespace, schemaLocation) {
        logger.log(`>>> resolveDependencyUrl called <<<`);
        logger.log(`Input - namespace: "${namespace}", schemaLocation: "${schemaLocation}"`);

        // If schemaLocation is already absolute, use it as-is
        if (schemaLocation.startsWith('http://') || schemaLocation.startsWith('https://')) {
          const result = {
            resolvedUrl: schemaLocation,
            fileName: getFileNameFromUrl(schemaLocation)
          };
          logger.log(`SchemaLocation is absolute URL, result:`, result);
          return result;
        }

        let resolvedUrl = schemaLocation;

        // If namespace exists and schemaLocation is relative, construct URL from namespace
        if (namespace && !schemaLocation.startsWith('/')) {
          logger.log(`Namespace exists and schemaLocation is relative, constructing URL...`);

          // Remove trailing slash from namespace if present
          const baseNamespace = namespace.endsWith('/') ? namespace.slice(0, -1) : namespace;
          logger.log(`Base namespace (after removing trailing slash): "${baseNamespace}"`);

          // Construct full URL by combining namespace with schemaLocation
          resolvedUrl = baseNamespace + '/' + schemaLocation;
          logger.log(`Constructed resolved URL: "${resolvedUrl}"`);
        } else {
          logger.log(`No namespace or schemaLocation is absolute/root path, using schemaLocation as-is`);
        }

        const result = {
          resolvedUrl: resolvedUrl,
          fileName: schemaLocation // Keep original filename for file system
        };

        logger.log(`>>> resolveDependencyUrl result <<<`, result);
        return result;
      }

      // Get base URL from a full URL
      function getBaseUrl(url) {
        const lastSlashIndex = url.lastIndexOf('/');
        return lastSlashIndex >= 0 ? url.substring(0, lastSlashIndex + 1) : '';
      }

      // Resolve relative URL against base URL (fallback for non-namespace cases)
      function resolveUrl(relativeUrl, baseUrl) {
        if (relativeUrl.startsWith('http://') || relativeUrl.startsWith('https://')) {
          return relativeUrl; // Already absolute
        }

        if (relativeUrl.startsWith('/')) {
          // Absolute path - need to get the origin from baseUrl
          const urlObj = new URL(baseUrl);
          return urlObj.origin + relativeUrl;
        }

        // Relative path
        return baseUrl + relativeUrl;
      }

      function validate() {
        logger.log("=== VALIDATION STARTED ===");

        try {
          // Write main schema to virtual file system
          const mainSchemaFileName = getFileNameFromUrl(xsdFileUrl);
          logger.log(`Writing main schema to virtual FS: /${mainSchemaFileName}`);
          Module.FS.writeFile('/' + mainSchemaFileName, mainSchemaContent);

          // Write all dependency schemas to virtual file system
          logger.log("Writing dependency schemas to virtual FS:");
          dependencySchemas.forEach((content, fileName) => {
            const cleanFileName = fileName.split('/').pop(); // Get just the filename
            logger.log(`  Writing: /${cleanFileName} (original: ${fileName})`);
            Module.FS.writeFile('/' + cleanFileName, content);
          });

          logger.log("Allocating memory for XML content...");
          // Write the XML string to memory
          const ptrXml = Module._malloc(lengthBytesUTF8(xml) + 1);
          stringToUTF8(xml, Module.HEAPU8, ptrXml, lengthBytesUTF8(xml) + 1);
          logger.log("XML written to memory at pointer:", ptrXml);

          logger.log("Parsing XML document...");
          // Parse XML document
          const xmlDoc = Module.ccall(
            'xmlReadMemory',
            'number',
            ['number', 'number', 'number', 'number', 'number'],
            [ptrXml, lengthBytesUTF8(xml), null, null, 0]
          );
          logger.log("XML document parsed, pointer:", xmlDoc);

          logger.log(`Creating schema parser context for: /${mainSchemaFileName}`);
          // Load schema from main file
          const schemaParserCtx = Module.ccall(
            'xmlSchemaNewParserCtxt',
            'number',
            ['string'],
            ['/' + mainSchemaFileName]
          );
          logger.log("Schema parser context created:", schemaParserCtx);

          logger.log("Parsing schema...");
          // Parse schema and create validation context
          const schema = Module.ccall('xmlSchemaParse', 'number', ['number'], [schemaParserCtx]);
          logger.log("Schema parsed, pointer:", schema);

          logger.log("Creating validation context...");
          const validCtx = Module.ccall('xmlSchemaNewValidCtxt', 'number', ['number'], [schema]);
          logger.log("Validation context created:", validCtx);

          logger.log("Validating XML document against schema...");
          // Validate XML
          const result = Module.ccall(
            'xmlSchemaValidateDoc',
            'number',
            ['number', 'number'],
            [validCtx, xmlDoc]
          );
          logger.log("Validation completed, raw result:", result);

          logger.log("Cleaning up memory...");
          // Release memory
          Module.ccall('xmlFreeDoc', 'void', ['number'], [xmlDoc]);
          Module.ccall('xmlSchemaFreeValidCtxt', 'void', ['number'], [validCtx]);
          Module.ccall('xmlSchemaFree', 'void', ['number'], [schema]);
          Module.ccall('xmlSchemaFreeParserCtxt', 'void', ['number'], [schemaParserCtx]);
          Module._free(ptrXml);
          logger.log("Memory cleanup completed");

          logger.log("=== VALIDATION RESULT ===");
          logger.log("Raw validation result:", result);
          logger.log("Validation success:", result === 0);

          // Return result (0 = valid, non-zero = invalid)
          const isValid = result === 0;
          logger.log("=== VALIDATION FINISHED ===");
          return isValid;

        } catch (error) {
          logger.error("=== VALIDATION ERROR ===", error);
          logger.error("Error stack:", error.stack);
          return false;
        }
      }

      // Extract filename from URL
      function getFileNameFromUrl(url) {
        return url.split('/').pop() || 'schema.xsd';
      }

      function stringToUTF8(str, heap, offset, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0)) return 0;
        const utf8encoder = new TextEncoder();
        const encoded = utf8encoder.encode(str);
        const len = Math.min(encoded.length, maxBytesToWrite - 1);
        heap.set(encoded.subarray(0, len), offset);
        heap[offset + len] = 0;
        return len;
      }
    </script>
  </body>
</html>