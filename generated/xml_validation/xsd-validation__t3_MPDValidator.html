<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>XSD Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script src="../lib/xsdValidation/output.js"></script>
    <script>
      console.log("Execution begin of last script");
      // Global variables
      var TEST_INFO = {
        id: "xsd-validation",
        title: "XSD Validation for MPD files",
        description:
          "Template for XSD Validations.",
        code: "xsd-validation.html",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = ["https://dash.akamaized.net/WAVE/vectors/cfhd_sets/15_30_60/t3/2023-09-01/stream.mpd"];
      var xsdFileUrl = ["https://raw.githubusercontent.com/Dash-Industry-Forum/MPEG-Conformance-and-reference-source/refs/heads/master/conformance/MPDValidator/schemas/DASH-MPD.xsd"]; // Now used for XSD file URL

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: xsdFileUrl,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      var xml;
      var mainSchemaContent;
      var dependencySchemas = new Map(); // Store all dependency schemas

      // Initialize the loading process
      initializeSchemas();

      async function initializeSchemas() {
        try {
          await getXml();
          await loadMainSchemaAndDependencies();
        } catch (error) {
          console.error("Error initializing schemas:", error);
        }
      }

      function executeTest(player, done, parameters) {
        console.log("In function executeTest");
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        dpctfTest.asyncTest(function (test) {
          console.log("In anonym function in asyncTest");

          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;
          console.log("Before validate call");
          let result = validate();

          console.log(result);

          assert_true(result);
          test.done();

        }, "MPD Schema Validation");

        player.playOnBufferLoaded(minBufferDuration).then(done);
      }

      // Save MPD file as utf-8 string
      async function getXml() {
        console.log("In function getXml");
        xml = await fetch(videoContentModel[0])
        .then(res => res.text());
        xml = JSON.parse( JSON.stringify( xml ) );
        if (!xml.includes('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"') || !xml.includes('xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"')) {
            xml = xml.replace('<MPD', '<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');
        }
      }

      // Load main schema and automatically discover and load dependencies
      async function loadMainSchemaAndDependencies() {
        console.log("Loading main schema and dependencies");

        try {
          // Load main schema
          mainSchemaContent = await fetch(xsdFileUrl)
            .then(res => res.text());
          mainSchemaContent = JSON.parse(JSON.stringify(mainSchemaContent));

          // Extract base URL for relative imports
          const baseUrl = getBaseUrl(xsdFileUrl);

          // Find and load all dependencies recursively
          await loadDependenciesRecursively(mainSchemaContent, baseUrl, new Set());

          console.log("All schemas loaded successfully");
        } catch (error) {
          console.error("Error loading schemas:", error);
          throw error;
        }
      }

      // Extract dependencies from XSD content and load them recursively
      async function loadDependenciesRecursively(schemaContent, baseUrl, loadedSchemas) {
        const dependencies = extractDependencies(schemaContent);

        for (const dependency of dependencies) {
          if (loadedSchemas.has(dependency)) {
            continue; // Already loaded
          }

          loadedSchemas.add(dependency);

          try {
            const dependencyUrl = resolveUrl(dependency, baseUrl);
            console.log(`Loading dependency: ${dependencyUrl}`);

            const dependencyContent = await fetch(dependencyUrl)
              .then(res => res.text());
            const cleanContent = JSON.parse(JSON.stringify(dependencyContent));

            dependencySchemas.set(dependency, cleanContent);

            // Recursively load dependencies of this dependency
            const depBaseUrl = getBaseUrl(dependencyUrl);
            await loadDependenciesRecursively(cleanContent, depBaseUrl, loadedSchemas);

          } catch (error) {
            console.warn(`Could not load dependency ${dependency}:`, error);
          }
        }
      }

      // Extract import and include statements from XSD content
      function extractDependencies(schemaContent) {
        const dependencies = [];

        // Regular expressions to find import and include statements
        const importRegex = /<xs:import[^>]*schemaLocation\s*=\s*["']([^"']+)["'][^>]*>/gi;
        const includeRegex = /<xs:include[^>]*schemaLocation\s*=\s*["']([^"']+)["'][^>]*>/gi;

        let match;

        // Find imports
        while ((match = importRegex.exec(schemaContent)) !== null) {
          dependencies.push(match[1]);
        }

        // Find includes
        while ((match = includeRegex.exec(schemaContent)) !== null) {
          dependencies.push(match[1]);
        }

        // Also check for schema without xs prefix
        const importRegex2 = /<import[^>]*schemaLocation\s*=\s*["']([^"']+)["'][^>]*>/gi;
        const includeRegex2 = /<include[^>]*schemaLocation\s*=\s*["']([^"']+)["'][^>]*>/gi;

        while ((match = importRegex2.exec(schemaContent)) !== null) {
          dependencies.push(match[1]);
        }

        while ((match = includeRegex2.exec(schemaContent)) !== null) {
          dependencies.push(match[1]);
        }

        console.log("Found dependencies:", dependencies);
        return dependencies;
      }

      // Get base URL from a full URL
      function getBaseUrl(url) {
        const lastSlashIndex = url.lastIndexOf('/');
        return lastSlashIndex >= 0 ? url.substring(0, lastSlashIndex + 1) : '';
      }

      // Resolve relative URL against base URL
      function resolveUrl(relativeUrl, baseUrl) {
        if (relativeUrl.startsWith('http://') || relativeUrl.startsWith('https://')) {
          return relativeUrl; // Already absolute
        }

        if (relativeUrl.startsWith('/')) {
          // Absolute path - need to get the origin from baseUrl
          const urlObj = new URL(baseUrl);
          return urlObj.origin + relativeUrl;
        }

        // Relative path
        return baseUrl + relativeUrl;
      }

      function validate() {
        console.log("In function validate");

        try {
          // Write main schema to virtual file system
          const mainSchemaFileName = getFileNameFromUrl(xsdFileUrl);
          Module.FS.writeFile('/' + mainSchemaFileName, mainSchemaContent);

          // Write all dependency schemas to virtual file system
          dependencySchemas.forEach((content, fileName) => {
            const cleanFileName = fileName.split('/').pop(); // Get just the filename
            Module.FS.writeFile('/' + cleanFileName, content);
          });

          // Write the XML string to memory
          const ptrXml = Module._malloc(lengthBytesUTF8(xml) + 1);
          stringToUTF8(xml, Module.HEAPU8, ptrXml, lengthBytesUTF8(xml) + 1);

          // Parse XML document
          const xmlDoc = Module.ccall(
            'xmlReadMemory',
            'number',
            ['number', 'number', 'number', 'number', 'number'],
            [ptrXml, lengthBytesUTF8(xml), null, null, 0]
          );

          // Load schema from main file
          const schemaParserCtx = Module.ccall(
            'xmlSchemaNewParserCtxt',
            'number',
            ['string'],
            ['/' + mainSchemaFileName]
          );

          // Parse schema and create validation context
          const schema = Module.ccall('xmlSchemaParse', 'number', ['number'], [schemaParserCtx]);
          const validCtx = Module.ccall('xmlSchemaNewValidCtxt', 'number', ['number'], [schema]);

          // Validate XML
          const result = Module.ccall(
            'xmlSchemaValidateDoc',
            'number',
            ['number', 'number'],
            [validCtx, xmlDoc]
          );

          // Release memory
          Module.ccall('xmlFreeDoc', 'void', ['number'], [xmlDoc]);
          Module.ccall('xmlSchemaFreeValidCtxt', 'void', ['number'], [validCtx]);
          Module.ccall('xmlSchemaFree', 'void', ['number'], [schema]);
          Module.ccall('xmlSchemaFreeParserCtxt', 'void', ['number'], [schemaParserCtx]);
          Module._free(ptrXml);

          console.log("Validation result:", result);

          // Return result (0 = valid, non-zero = invalid)
          return result === 0;

        } catch (error) {
          console.error("Validation error:", error);
          return false;
        }
      }

      // Extract filename from URL
      function getFileNameFromUrl(url) {
        return url.split('/').pop() || 'schema.xsd';
      }

      function stringToUTF8(str, heap, offset, maxBytesToWrite) {
        console.log("In function stringToUTF8");
        if (!(maxBytesToWrite > 0)) return 0;
        const utf8encoder = new TextEncoder();
        const encoded = utf8encoder.encode(str);
        const len = Math.min(encoded.length, maxBytesToWrite - 1);
        heap.set(encoded.subarray(0, len), offset);
        heap[offset + len] = 0;
        return len;
      }
    </script>
  </body>
</html>