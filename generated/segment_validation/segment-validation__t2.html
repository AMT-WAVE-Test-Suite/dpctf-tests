<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Segment Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script type="module">
      import * as MP4Box from '../lib/mp4box.all.js';
      
      // Global variables
      var TEST_INFO = {
        id: "segment-validation",
        title: "Segment Validation",
        description:
          "Test if segments exists on server side with HTTP HEAD requests.",
        code: "segment-validation.html",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = ["/content/cfhd_sets/14.985_29.97_59.94/t2/2023-09-01/stream.mpd"];
      var audioContentModel = [];

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: audioContentModel,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      async function executeTest(player, done, parameters) {
        var logger = dpctfTest.getLogger();
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        // save MPD file as utf-8 string
        let mpd = await fetch(videoContentModel[0])
        .then(res => res.text());
        mpd = JSON.parse( JSON.stringify( mpd ) );
        logger.log("MPD loaded successfully");
        
        let baseUrl = videoContentModel[0].split("/").filter(e => !e.includes(".mpd")).join("/") + "/";
        let segmentList = mpdParser.parse(mpd);

        // adjust extracted uris that they can be requested
        let segmentUri = segmentList.playlists[0].segments.map(e => e.uri).map(e => baseUrl + e);
        let segmentDuration = segmentList.playlists[0].segments.map(e => e.duration);

        dpctfTest.asyncTest(function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let testPass = true;
          let segmentTest = [];
          for (let i = 0; i < segmentUri.length; i++) {
            segmentTest.push(fetch(segmentUri[i], {method: "HEAD"})
            .then(res => {
                if (String(res.status).startsWith("4") || String(res.status).startsWith("5")) {
                  logger.log(`Segment ${i} not exist! Test failed.`);
                  testPass = false;
                } else {
                  logger.log(`Segment ${i} exist.`);
                }
            }));
          }

          Promise.all(segmentTest)
          .then(() => {
            assert_true(testPass);
            test.done();
          })
          .catch(err => {
            console.error(err);
            assert_true(false);
            test.done();
          });

        }, "Segment exist on Server");


        dpctfTest.asyncTest(function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let testResult = true;
          Promise.all(startAnalyzing())
          .then(res => {
            if (res.some(results => results == false)) {
              assert_true(false);
            } else {
              assert_true(true);
            }
            test.done();
          })
          .catch(err => {
            console.error(err);
            assert_true(false);
            test.done();
          });
        }, "Segment duration correct");

        // MPD Datei die Validiert werden soll
        async function startAnalyzing () {
            let mpd = await fetch("./stream.mpd")
            .then((res) => res.text());
            mpd = JSON.parse( JSON.stringify( mpd ) );

            let baseUrl = videoContentModel[0].split("/").filter(e => !e.includes(".mpd")).join("/") + "/";
            console.log(baseUrl);
            let segmentList = mpdParser.parse(mpd);
            console.log(segmentList);
            let segmentUri = segmentList.playlists[0].segments.map(e => e.uri).map(e => baseUrl + e);
            console.log(segmentUri);
            let segmentDuration =segmentList .playlists[0].segments.map(e => e.duration);
            console.log(segmentDuration);

           let initUrl = segmentUri[0].split("/").filter(e => !e.includes('.m4s')).join('/') + "/init.mp4";
           let init = await fetch(initUrl)
           .then(res => res.arrayBuffer());

           let results = [];
           for (let i = 0; i < segmentUri.length; i++) {
                results.push(fetch(segmentUri[i])
                .then(res => res.arrayBuffer())
                .then(segment => analyzeSegment(init, segment, segmentDuration[i])));               
           }
           return results;
        }

        async function analyzeSegment (init, segment, expectedDuration) {
            // set start of the segment behind the init
            init.fileStart = 0;
            segment.fileStart = init.byteLength;    
            
            var mp4boxfile = MP4Box.createFile();
            var allSamples = [];
           
            mp4boxfile.onReady = function (info) {
                for (const track of info.tracks) {
                    mp4boxfile.setExtractionOptions(track.id, null, { nbSamples: Infinity });
                    mp4boxfile.start();
                }

                mp4boxfile.flush();

                setTimeout(() => {
                    for (const track of info.tracks) {
                        if (!allSamples[track.id]) continue;
                        let samples = allSamples[track.id];
                        
                        // aggregate durations of the samples
                        let durationUnits = samples.reduce((acc, cur) => acc + cur.duration, 0);
                        let durationSeconds = durationUnits / track.timescale;

                        logger.log("Expected duration: " + expectedDuration + " - Real duration: " + durationSeconds);

                        if (expectedDuration == durationSeconds) {
                          return true;
                        } else {
                          logger.log("Segment duration incorrect!");
                          return false;
                        }
                        
                    }
                }, 100);
            };

            // write samples to the respective track_id
            mp4boxfile.onSamples = function (track_id, user, samples) {
                if (!allSamples[track_id]) allSamples[track_id] = [];
                allSamples[track_id].push(...samples);
            };

            mp4boxfile.appendBuffer(init);
            mp4boxfile.appendBuffer(segment);
        }
        
        player.playOnBufferLoaded(minBufferDuration).then(done);
      }
    </script>
  </body>
</html>
