<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>XSD Validation</title>
    <link rel="stylesheet" href="../lib/style.css" />
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>

  <body>
    <div id="content-wrapper">
      <div id="video-wrapper">
        <video></video>
        <div><div id="qr-code"></div></div>
        <div><div id="status-text"></div></div>
      </div>
      <div>To show/hide debug overlay press up/down or button beneath</div>
      <div id="debug-wrapper">
        <div>
          <div class="button" id="debug-button">Debug Overlay</div>
        </div>
        <div id="debug"></div>
        <div id="log"></div>
      </div>
    </div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/davidshimjs/qrcode.js"></script>
    <script src="../lib/dpctf-testharness.js"></script>
    <script src="../lib/hbbtv.js"></script>
    <script src="../lib/xsdValidation/output.js"></script>
    <script>
      // Global variables
      var TEST_INFO = {
        id: "xsd-validation",
        title: "XSD Validation for MPD files",
        description:
          "Template for XSD Validations.",
        code: "{{TEMPLATE_NAME}}",
      };

      var video = document.querySelector("video");
      var qrCode = document.getElementById("qr-code");
      var statusText = document.getElementById("status-text");

      var videoContentModel = "{{VIDEO_MPD_URL}}";
      var xsdFileUrl = "{{AUDIO_MPD_URL}}"; // Now used for XSD file URL

      var dpctfTest = new DpctfTest({
        testInfo: TEST_INFO,
        videoContentModel: videoContentModel,
        audioContentModel: xsdFileUrl,
        videoElement: video,
        qrCodeElement: qrCode,
        statusTextElement: statusText,
        infoOverlayElement: document.getElementById("info-overlay"),
        executeTest: executeTest,
        usePlayout: false,
      });

      var logger = dpctfTest.getLogger();
      var xml;
      var mainSchemaContent;
      var dependencySchemas = new Map(); // Store all dependency schemas

      const INLINE = {
        'http://www.w3.org/1999/xlink.xsd': `<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.w3.org/1999/xlink" xmlns:xlink="http://www.w3.org/1999/xlink">

 <xs:annotation>
  <xs:documentation>This schema is not normative, or even definitive.  The
prose copy in the XLink 1.1 recommendation (http://www.w3.org/TR/xlink11/) is
definitive, although it should not differ from this file, except for the
absence of these two initial comments.</xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>In keeping with the W3C's standard versioning
   policy, this schema document will persist at
   http://www.w3.org/XML/2008/06/xlink.xsd.
   At the date of issue it can also be found at
   http://www.w3.org/1999/xlink.xsd.
   The schema document at that URI may however change in the future,
   in order to remain compatible with the latest version of XML Schema
   itself, or with the XLink namespace itself.  In other words, if the XML
   Schema or XLink namespaces change, the version of this document at
   http://www.w3.org/1999/xlink.xsd will change
   accordingly; the version at
   http://www.w3.org/2008/06/xlink.xsd will not change.
</xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>This schema document provides attribute declarations and
attribute group, complex type and simple type definitions which can be used in
the construction of user schemas to define the structure of particular linking
constructs, e.g.
<![CDATA[
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xl="http://www.w3.org/1999/xlink">

 <xs:import namespace="http://www.w3.org/1999/xlink"
            location="http://www.w3.org/1999/xlink.xsd">

 <xs:element name="mySimple">
  <xs:complexType>
   ...
   <xs:attributeGroup ref="xl:simpleAttrs"/>
   ...
  </xs:complexType>
 </xs:element>
 ...
</xs:schema>]]></xs:documentation>
 </xs:annotation>

 <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="xml.xsd"/>

 <xs:attribute name="type" type="xlink:typeType"/>

 <xs:simpleType name="typeType">
  <xs:restriction base="xs:token">
   <xs:enumeration value="simple"/>
   <xs:enumeration value="extended"/>
   <xs:enumeration value="title"/>
   <xs:enumeration value="resource"/>
   <xs:enumeration value="locator"/>
   <xs:enumeration value="arc"/>
  </xs:restriction>
 </xs:simpleType>

 <xs:attribute name="href" type="xlink:hrefType"/>

 <xs:simpleType name="hrefType">
  <xs:restriction base="xs:anyURI"/>
 </xs:simpleType>

 <xs:attribute name="role" type="xlink:roleType"/>

 <xs:simpleType name="roleType">
  <xs:restriction base="xs:anyURI">
   <xs:minLength value="1"/>
  </xs:restriction>
 </xs:simpleType>

 <xs:attribute name="arcrole" type="xlink:arcroleType"/>

 <xs:simpleType name="arcroleType">
  <xs:restriction base="xs:anyURI">
   <xs:minLength value="1"/>
  </xs:restriction>
 </xs:simpleType>

 <xs:attribute name="title" type="xlink:titleAttrType"/>

 <xs:simpleType name="titleAttrType">
  <xs:restriction base="xs:string"/>
 </xs:simpleType>

 <xs:attribute name="show" type="xlink:showType"/>

 <xs:simpleType name="showType">
  <xs:restriction base="xs:token">
   <xs:enumeration value="new"/>
   <xs:enumeration value="replace"/>
   <xs:enumeration value="embed"/>
   <xs:enumeration value="other"/>
   <xs:enumeration value="none"/>
  </xs:restriction>
 </xs:simpleType>

 <xs:attribute name="actuate" type="xlink:actuateType"/>

 <xs:simpleType name="actuateType">
  <xs:restriction base="xs:token">
   <xs:enumeration value="onLoad"/>
   <xs:enumeration value="onRequest"/>
   <xs:enumeration value="other"/>
   <xs:enumeration value="none"/>
  </xs:restriction>
 </xs:simpleType>

 <xs:attribute name="label" type="xlink:labelType"/>

 <xs:simpleType name="labelType">
  <xs:restriction base="xs:NCName"/>
 </xs:simpleType>

 <xs:attribute name="from" type="xlink:fromType"/>

 <xs:simpleType name="fromType">
  <xs:restriction base="xs:NCName"/>
 </xs:simpleType>

 <xs:attribute name="to" type="xlink:toType"/>

 <xs:simpleType name="toType">
  <xs:restriction base="xs:NCName"/>
 </xs:simpleType>

 <xs:attributeGroup name="simpleAttrs">
  <xs:attribute ref="xlink:type" fixed="simple"/>
  <xs:attribute ref="xlink:href"/>
  <xs:attribute ref="xlink:role"/>
  <xs:attribute ref="xlink:arcrole"/>
  <xs:attribute ref="xlink:title"/>
  <xs:attribute ref="xlink:show"/>
  <xs:attribute ref="xlink:actuate"/>
 </xs:attributeGroup>

 <xs:group name="simpleModel">
  <xs:sequence>
   <xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:group>

 <xs:complexType mixed="true" name="simple">
  <xs:annotation>
   <xs:documentation>
    Intended for use as the type of user-declared elements to make them
    simple links.
   </xs:documentation>
  </xs:annotation>
  <xs:group ref="xlink:simpleModel"/>
  <xs:attributeGroup ref="xlink:simpleAttrs"/>
 </xs:complexType>

 <xs:attributeGroup name="extendedAttrs">
  <xs:attribute ref="xlink:type" fixed="extended" use="required"/>
  <xs:attribute ref="xlink:role"/>
  <xs:attribute ref="xlink:title"/>
 </xs:attributeGroup>

 <xs:group name="extendedModel">
   <xs:choice>
    <xs:element ref="xlink:title"/>
    <xs:element ref="xlink:resource"/>
    <xs:element ref="xlink:locator"/>
    <xs:element ref="xlink:arc"/>
  </xs:choice>
 </xs:group>

 <xs:complexType name="extended">
  <xs:annotation>
   <xs:documentation>
    Intended for use as the type of user-declared elements to make them
    extended links.
    Note that the elements referenced in the content model are all abstract.
    The intention is that by simply declaring elements with these as their
    substitutionGroup, all the right things will happen.
   </xs:documentation>
  </xs:annotation>
  <xs:group ref="xlink:extendedModel" minOccurs="0" maxOccurs="unbounded"/>
  <xs:attributeGroup ref="xlink:extendedAttrs"/>
 </xs:complexType>

 <xs:element name="title" type="xlink:titleEltType" abstract="true"/>

 <xs:attributeGroup name="titleAttrs">
  <xs:attribute ref="xlink:type" fixed="title" use="required"/>
  <xs:attribute ref="xml:lang">
   <xs:annotation>
    <xs:documentation>
     xml:lang is not required, but provides much of the
     motivation for title elements in addition to attributes, and so
     is provided here for convenience.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup>

 <xs:group name="titleModel">
  <xs:sequence>
   <xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:group>

 <xs:complexType mixed="true" name="titleEltType">
  <xs:group ref="xlink:titleModel"/>
  <xs:attributeGroup ref="xlink:titleAttrs"/>
 </xs:complexType>

 <xs:element name="resource" type="xlink:resourceType" abstract="true"/>

 <xs:attributeGroup name="resourceAttrs">
  <xs:attribute ref="xlink:type" fixed="resource" use="required"/>
  <xs:attribute ref="xlink:role"/>
  <xs:attribute ref="xlink:title"/>
  <xs:attribute ref="xlink:label"/>
 </xs:attributeGroup>

 <xs:group name="resourceModel">
  <xs:sequence>
   <xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:group>

 <xs:complexType mixed="true" name="resourceType">
  <xs:group ref="xlink:resourceModel"/>
  <xs:attributeGroup ref="xlink:resourceAttrs"/>
 </xs:complexType>

 <xs:element name="locator" type="xlink:locatorType" abstract="true"/>

 <xs:attributeGroup name="locatorAttrs">
  <xs:attribute ref="xlink:type" fixed="locator" use="required"/>
  <xs:attribute ref="xlink:href" use="required"/>
  <xs:attribute ref="xlink:role"/>
  <xs:attribute ref="xlink:title"/>
  <xs:attribute ref="xlink:label">
   <xs:annotation>
    <xs:documentation>
     label is not required, but locators have no particular
     XLink function if they are not labeled.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup>

 <xs:group name="locatorModel">
  <xs:sequence>
   <xs:element ref="xlink:title" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:group>

 <xs:complexType name="locatorType">
  <xs:group ref="xlink:locatorModel"/>
  <xs:attributeGroup ref="xlink:locatorAttrs"/>
 </xs:complexType>

 <xs:element name="arc" type="xlink:arcType" abstract="true"/>

 <xs:attributeGroup name="arcAttrs">
  <xs:attribute ref="xlink:type" fixed="arc" use="required"/>
  <xs:attribute ref="xlink:arcrole"/>
  <xs:attribute ref="xlink:title"/>
  <xs:attribute ref="xlink:show"/>
  <xs:attribute ref="xlink:actuate"/>
  <xs:attribute ref="xlink:from"/>
  <xs:attribute ref="xlink:to">
   <xs:annotation>
    <xs:documentation>
     from and to have default behavior when values are missing
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup>

 <xs:group name="arcModel">
  <xs:sequence>
   <xs:element ref="xlink:title" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:group>

 <xs:complexType name="arcType">
  <xs:group ref="xlink:arcModel"/>
  <xs:attributeGroup ref="xlink:arcAttrs"/>
 </xs:complexType>

</xs:schema>
`,
        'http://www.w3.org/XML/1998/xml.xsd'  : `<?xml version='1.0'?>
<!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200102//EN" "XMLSchema.dtd" >
<xs:schema targetNamespace="http://www.w3.org/XML/1998/namespace" xmlns:xs="http://www.w3.org/2001/XMLSchema" xml:lang="en">

 <xs:annotation>
  <xs:documentation>
   See http://www.w3.org/XML/1998/namespace.html and
   http://www.w3.org/TR/REC-xml for information about this namespace.

    This schema document describes the XML namespace, in a form
    suitable for import by other schema documents.

    Note that local names in this namespace are intended to be defined
    only by the World Wide Web Consortium or its subgroups.  The
    following names are currently defined in this namespace and should
    not be used with conflicting semantics by any Working Group,
    specification, or document instance:

    base (as an attribute name): denotes an attribute whose value
         provides a URI to be used as the base for interpreting any
         relative URIs in the scope of the element on which it
         appears; its value is inherited.  This name is reserved
         by virtue of its definition in the XML Base specification.

    lang (as an attribute name): denotes an attribute whose value
         is a language code for the natural language of the content of
         any element; its value is inherited.  This name is reserved
         by virtue of its definition in the XML specification.

    space (as an attribute name): denotes an attribute whose
         value is a keyword indicating what whitespace processing
         discipline is intended for the content of the element; its
         value is inherited.  This name is reserved by virtue of its
         definition in the XML specification.

    Father (in any context at all): denotes Jon Bosak, the chair of
         the original XML Working Group.  This name is reserved by
         the following decision of the W3C XML Plenary and
         XML Coordination groups:

             In appreciation for his vision, leadership and dedication
             the W3C XML Plenary on this 10th day of February, 2000
             reserves for Jon Bosak in perpetuity the XML name
             xml:Father
  </xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>This schema defines attributes and an attribute group
        suitable for use by
        schemas wishing to allow xml:base, xml:lang or xml:space attributes
        on elements they define.

        To enable this, such a schema must import this schema
        for the XML namespace, e.g. as follows:
        &lt;schema . . .>
         . . .
         &lt;import namespace="http://www.w3.org/XML/1998/namespace"
                    schemaLocation="http://www.w3.org/2001/03/xml.xsd"/>

        Subsequently, qualified reference to any of the attributes
        or the group defined below will have the desired effect, e.g.

        &lt;type . . .>
         . . .
         &lt;attributeGroup ref="xml:specialAttrs"/>

         will define a type which will schema-validate an instance
         element with any of those attributes</xs:documentation>
 </xs:annotation>

 <xs:annotation>
  <xs:documentation>In keeping with the XML Schema WG's standard versioning
   policy, this schema document will persist at
   http://www.w3.org/2001/03/xml.xsd.
   At the date of issue it can also be found at
   http://www.w3.org/2001/xml.xsd.
   The schema document at that URI may however change in the future,
   in order to remain compatible with the latest version of XML Schema
   itself.  In other words, if the XML Schema namespace changes, the version
   of this document at
   http://www.w3.org/2001/xml.xsd will change
   accordingly; the version at
   http://www.w3.org/2001/03/xml.xsd will not change.
  </xs:documentation>
 </xs:annotation>

 <xs:attribute name="lang" type="xs:language">
  <xs:annotation>
   <xs:documentation>In due course, we should install the relevant ISO 2- and 3-letter
         codes as the enumerated possible values . . .</xs:documentation>
  </xs:annotation>
 </xs:attribute>

 <xs:attribute name="space" default="preserve">
  <xs:simpleType>
   <xs:restriction base="xs:NCName">
    <xs:enumeration value="default"/>
    <xs:enumeration value="preserve"/>
   </xs:restriction>
  </xs:simpleType>
 </xs:attribute>

 <xs:attribute name="base" type="xs:anyURI">
  <xs:annotation>
   <xs:documentation>See http://www.w3.org/TR/xmlbase/ for
                     information about this attribute.</xs:documentation>
  </xs:annotation>
 </xs:attribute>

 <xs:attributeGroup name="specialAttrs">
  <xs:attribute ref="xml:base"/>
  <xs:attribute ref="xml:lang"/>
  <xs:attribute ref="xml:space"/>
 </xs:attributeGroup>

</xs:schema>
`
      };

      // Initialize the loading process
      initializeSchemas();

      async function initializeSchemas() {
        logger.log("INITIALIZATION STARTED");
        try {
          await getXml();
          await loadMainSchemaAndDependencies();
          logger.log("INITIALIZATION COMPLETED SUCCESSFULLY ");
        } catch (error) {
          logger.error("INITIALIZATION FAILED ", error);
        }
      }

      function executeTest(player, done, parameters) {
        var minBufferDuration = parameters.minBufferDuration / 1000;
        player.startBuffering();

        dpctfTest.asyncTest(function (test) {
          var query = location.search.replace(/\?/, "");
          var match = query.match(/redirect_time=([^&]+)/);
          var REDIRECT_TIME = match ? match[1] : null;
          if (!REDIRECT_TIME) REDIRECT_TIME = 5;

          let result = validate();

          logger.log("MPD Validation result: " + result);

          assert_true(result);
          test.done();

        }, "MPD Schema Validation");

        player.playOnBufferLoaded(minBufferDuration).then(done);
      }

      // Save MPD file as utf-8 string
      async function getXml() {
        logger.log("Loading MPD XML file...");
        logger.log("MPD URL:", videoContentModel[0]);

        xml = await fetch(videoContentModel[0])
        .then(res => {
          logger.log("MPD fetch response status:", res.status);
          return res.text();
        });
        xml = JSON.parse( JSON.stringify( xml ) );

        logger.log("Original XML length:", xml.length);
        logger.log("Checking for required schema attributes...");

        const hasXmlSchemaInstance = xml.includes('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"');
        const hasSchemaLocation = xml.includes('xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');

        logger.log("Has xmlns:xsi attribute:", hasXmlSchemaInstance);
        logger.log("Has schemaLocation attribute:", hasSchemaLocation);

        if (!hasXmlSchemaInstance || !hasSchemaLocation) {
          logger.log("Adding missing schema attributes to MPD...");
          xml = xml.replace('<MPD', '<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd"');
          logger.log("Schema attributes added");
        } else {
          logger.log("Schema attributes already present");
        }

        logger.log(" MPD XML loaded successfully, final length:", xml.length);
      }

      // Load main schema and automatically discover and load dependencies
      async function loadMainSchemaAndDependencies() {
        logger.log("=== Loading main schema and dependencies ===");
        logger.log("Main XSD URL:", xsdFileUrl);

        try {
          // Load main schema
          logger.log("Fetching main schema from:", xsdFileUrl);
          mainSchemaContent = await fetch(xsdFileUrl)
            .then(res => {
              logger.log("Main schema fetch response status:", res.status);
              return res.text();
            });
          mainSchemaContent = JSON.parse(JSON.stringify(mainSchemaContent));
          logger.log("Main schema loaded, content length:", mainSchemaContent.length);

          // Find and load all dependencies recursively
          logger.log("Starting recursive dependency loading...");
          await loadDependenciesRecursively(mainSchemaContent, new Set());

          logger.log("=== All schemas loaded successfully ===");
          logger.log("Total dependencies loaded:", dependencySchemas.size);
          logger.log("Dependency files:", Array.from(dependencySchemas.keys()));
        } catch (error) {
          logger.error("=== Error loading schemas ===", error);
          throw error;
        }
      }

      // Extract dependencies from XSD content and load them recursively
      async function loadDependenciesRecursively(schemaContent, loadedSchemas) {
        const dependencies = extractDependencies(schemaContent);
        logger.log("Dependencies found:", dependencies.length);

        for (const dependency of dependencies) {
          const downloadUrl = dependency.domain + dependency.fileName;
          logger.log(`Processing dependency: "${downloadUrl}"`);

          if (loadedSchemas.has(downloadUrl)) {
            logger.log(`Skipping already loaded schema: ${downloadUrl}`);
            continue; // Already loaded
          }

          loadedSchemas.add(downloadUrl);
          logger.log(`Added to loaded schemas: ${downloadUrl}`);

          try {
            // logger.log(`Fetching dependency: ${downloadUrl}`);
            let xsdDependency;
            if (INLINE[downloadUrl]) {
              // (1) INLINE shortcut
              logger.log(`Using inline copy of ${downloadUrl}`);
              xsdDependency = INLINE[downloadUrl];

            } else {
              // (2) normal network fetch
              logger.log(`Fetching dependency: ${downloadUrl}`);
              xsdDependency = await fetch(downloadUrl)
                  .then(res => {
                    logger.log(`Dependency fetch response status for ${downloadUrl}:`, res.status);
                    if (!res.ok) {
                      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    return res.text();
                  });
            }
            const xsdDependencyString = JSON.parse(JSON.stringify(xsdDependency));


            logger.log(`Successfully loaded dependency "${dependency.fileName}", content length:`, xsdDependencyString.length);
            dependencySchemas.set(dependency.fileName, xsdDependencyString);

            // Recursively load dependencies of this dependency
            logger.log(`Recursively checking dependencies for ${dependency.fileName}`);
            await loadDependenciesRecursively(xsdDependencyString, loadedSchemas);

          } catch (error) {
            logger.warn(`Failed to load dependency "${dependency.fileName}" from ${downloadUrl}:`, error.message);
          }
        }

        logger.log("--- loadDependenciesRecursively completed ---");
      }

      // Extract import and include statements from XSD content
      function extractDependencies(schemaContent) {
        logger.log("*** extractDependencies called ***");
        logger.log("Schema content length:", schemaContent.length);

        const dependencies = [];

        // Combined regex to capture both namespace and schemaLocation
        const importRegex = /<xs:import[^>]*namespace\s*=\s*["']([^"']*\/)[^"']*["'][^>]*schemaLocation\s*=\s*["']([^"']*)["'][^>]*>/gi;

        let match;

        logger.log("Searching for import statements...");
        // Find imports with potential namespace resolution
        while ((match = importRegex.exec(schemaContent)) !== null) {
          logger.log(`Regex match: "${match}"`);
          const namespace = match[1];
          const schemaLocation = match[2];

          logger.log(`Found import - namespace: "${namespace}", schemaLocation: "${schemaLocation}"`);

          const includeDependency = {
            domain: namespace,
            fileName: schemaLocation
          };
          logger.log(`Include dependency:`, includeDependency);
          dependencies.push(includeDependency);

        }
        return dependencies;
      }

      function validate() {
        logger.log("=== VALIDATION STARTED ===");

        try {
          const mainSchemaFileName = xsdFileUrl.split('/').pop();

          // 1. write XSD-files into a virtual directory
          logger.log("Writing xsd-schemas to virtual FS:");
          Module.FS.writeFile('/' + mainSchemaFileName, mainSchemaContent);
          dependencySchemas.forEach((content, fileName) => {
            logger.log(`  Writing: /${fileName}`);
            Module.FS.writeFile('/' + fileName, content);
          });

          // 2. write the XML-string to memory
          logger.log("Allocating memory for XML content...");
          const ptrXml = Module._malloc(lengthBytesUTF8(xml) + 1);
          stringToUTF8(xml, Module.HEAPU8, ptrXml, lengthBytesUTF8(xml) + 1);
          logger.log("XML written to memory at pointer:", ptrXml);

          // 3. parse XML-document
          logger.log("Parsing XML document...");
          const xmlDoc = Module.ccall(
            'xmlReadMemory',
            'number',
            ['number', 'number', 'number', 'number', 'number'],
            [ptrXml, lengthBytesUTF8(xml), null, null, 0]
          );

          // 4. load scheme from file DASH-MPD.xsd (that imports work)
          logger.log(`Creating schema parser context for: /${mainSchemaFileName}`);
          const schemaParserCtx = Module.ccall(
            'xmlSchemaNewParserCtxt',
            'number',
            ['string'],
            ['/' + mainSchemaFileName]
          );
          logger.log("Schema parser context created:", schemaParserCtx);

          // 5. parse schema and create validation context
          const schema = Module.ccall('xmlSchemaParse', 'number', ['number'], [schemaParserCtx]);
          logger.log("Schema parsed, pointer:", schema);
          const validCtx = Module.ccall('xmlSchemaNewValidCtxt', 'number', ['number'], [schema]);
          logger.log("Validation context created:", validCtx);

          // 6. validate XML
          logger.log("Validating XML document against schema...");
          const result = Module.ccall(
            'xmlSchemaValidateDoc',
            'number',
            ['number', 'number'],
            [validCtx, xmlDoc]
          );

          // 7. release memory
          logger.log("Cleaning up memory...");
          Module.ccall('xmlFreeDoc', 'void', ['number'], [xmlDoc]);
          Module.ccall('xmlSchemaFreeValidCtxt', 'void', ['number'], [validCtx]);
          Module.ccall('xmlSchemaFree', 'void', ['number'], [schema]);
          Module.ccall('xmlSchemaFreeParserCtxt', 'void', ['number'], [schemaParserCtx]);
          Module._free(ptrXml);

          logger.log("=== VALIDATION RESULT ===");
          logger.log("Raw validation result:", result);
          logger.log("Validation success:", result === 0);

          // 8. return result
          const isValid = result === 0;
          logger.log("=== VALIDATION FINISHED ===");
          return isValid;

        } catch (error) {
          logger.error("=== VALIDATION ERROR ===", error);
          logger.error("Error stack:", error.stack);
          return false;
        }
      }

      function stringToUTF8(str, heap, offset, maxBytesToWrite) {
        logger.log("In function stringToUTF8");
        if (!(maxBytesToWrite > 0)) return 0;
        const utf8encoder = new TextEncoder();
        const encoded = utf8encoder.encode(str);
        const len = Math.min(encoded.length, maxBytesToWrite - 1);
        heap.set(encoded.subarray(0, len), offset);
        heap[offset + len] = 0;
        return len;
      }
    </script>
  </body>
</html>